From d43f49ba5d377a2ecea607f37a9c4a2efe67d5c5 Mon Sep 17 00:00:00 2001
From: Ed Smith <ed.smith@collabora.com>
Date: Thu, 28 Mar 2024 16:39:31 -0600
Subject: [PATCH] Register EAPOL frame listeners earlier

If we register the main EAPOL frame listener as late as the associate
event, it may not observe ptk_1_of_4. This defeats handling for early
messages in eapol_rx_packet, which only sees messages once it has been
registered.

If we move registration to the authenticate event, then the EAPOL
frame listeners should observe all messages, without any possible
races. Note that the messages are not actually processed until
eapol_start() is called, and we haven't moved that call site. All
that's changing here is how early EAPOL messages can be observed.
---
 src/netdev.c | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/src/netdev.c b/src/netdev.c
index 2b3925dc..624e87ed 100644
--- a/src/netdev.c
+++ b/src/netdev.c
@@ -2879,30 +2879,39 @@ static bool kernel_will_retry_auth(uint16_t status_code,
 		return true;
 
 	if (alg != MMPDU_AUTH_ALGO_SAE)
 		return false;
 
 	if (status_code == MMPDU_STATUS_CODE_ANTI_CLOGGING_TOKEN_REQ)
 		return true;
 
 	if (trans == 1 && (status_code == MMPDU_STATUS_CODE_SAE_PK ||
 			status_code == MMPDU_STATUS_CODE_SAE_HASH_TO_ELEMENT))
 		return true;
 
 	return false;
 }
 
+static void netdev_ensure_eapol_registered(struct netdev *netdev)
+{
+	if (L_WARN_ON(netdev->sm))
+		return;
+
+	netdev->sm = eapol_sm_new(netdev->handshake);
+	eapol_register(netdev->sm);
+}
+
 static void netdev_authenticate_event(struct l_genl_msg *msg,
 							struct netdev *netdev)
 {
 	struct l_genl_attr attr;
 	uint16_t type, len;
 	const void *data;
 	const uint8_t *frame = NULL;
 	size_t frame_len = 0;
 	int ret;
 	uint16_t status_code = MMPDU_STATUS_CODE_UNSPECIFIED;
 
 	l_debug("");
 
 	if (netdev->aborting)
 		return;
@@ -2954,31 +2963,36 @@ static void netdev_authenticate_event(struct l_genl_msg *msg,
 	if (netdev->ap) {
 		const struct mmpdu_header *hdr;
 		const struct mmpdu_authentication *auth;
 		bool retry;
 
 		hdr = mpdu_validate(frame, frame_len);
 		if (L_WARN_ON(!hdr))
 			goto auth_error;
 
 		auth = mmpdu_body(hdr);
 		status_code = L_CPU_TO_LE16(auth->status);
 
 		ret = auth_proto_rx_authenticate(netdev->ap, frame, frame_len);
 
 		/* We have sent another CMD_AUTHENTICATE / CMD_ASSOCIATE */
-		if (ret == 0 || ret == -EAGAIN)
+		if (ret == 0) {
+			netdev_ensure_eapol_registered(netdev);
+			return;
+		}
+
+		if (ret == -EAGAIN)
 			return;
 
 		retry = kernel_will_retry_auth(status_code,
 				L_CPU_TO_LE16(auth->algorithm),
 				L_CPU_TO_LE16(auth->transaction_sequence));
 
 		/*
 		 * Spec wants us to silently drop these frames,
 		 * if the kernel will keep retrying, let it
 		 */
 		if ((ret == -ENOMSG || ret == -EBADMSG) && retry)
 			return;
 
 		if (ret > 0)
 			status_code = (uint16_t)ret;
@@ -3071,33 +3085,30 @@ static void netdev_associate_event(struct l_genl_msg *msg,
 	else
 		ret = __ft_rx_associate(netdev->index, frame,
 							frame_len);
 	if (ret == 0) {
 		bool fils = !!(netdev->handshake->akm_suite &
 				(IE_RSN_AKM_SUITE_FILS_SHA256 |
 				 IE_RSN_AKM_SUITE_FILS_SHA384 |
 				 IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA384 |
 				 IE_RSN_AKM_SUITE_FT_OVER_FILS_SHA256));
 
 		if (netdev->ap) {
 			auth_proto_free(netdev->ap);
 			netdev->ap = NULL;
 		}
 
-		netdev->sm = eapol_sm_new(netdev->handshake);
-		eapol_register(netdev->sm);
-
 		/* Just in case this was a retry */
 		netdev->ignore_connect_event = false;
 
 		/*
 		 * If in FT and/or FILS we don't force an initial 4-way
 		 * handshake and instead just keep the EAPoL state
 		 * machine for the rekeys.
 		 */
 		if (netdev->in_ft || fils)
 			eapol_sm_set_require_handshake(netdev->sm,
 							false);
 
 		netdev->in_reassoc = false;
 		netdev->associated = true;
 		return;
@@ -4254,30 +4265,32 @@ int netdev_ft_reassociate(struct netdev *netdev,
 			nhs->group_management_new_key_cmd_id);
 		nhs->group_management_new_key_cmd_id = 0;
 	}
 
 	if (netdev->rekey_offload_cmd_id) {
 		l_genl_family_cancel(nl80211, netdev->rekey_offload_cmd_id);
 		netdev->rekey_offload_cmd_id = 0;
 	}
 
 	netdev_rssi_polling_update(netdev);
 	netdev_cqm_rssi_update(netdev);
 
 	if (netdev->sm) {
 		eapol_sm_free(netdev->sm);
 		netdev->sm = NULL;
+
+		netdev_ensure_eapol_registered(netdev);
 	}
 
 	msg = netdev_build_cmd_associate_common(netdev);
 
 	c_iov = netdev_populate_common_ies(netdev, hs, msg, iov, n_iov, c_iov);
 
 	if (hs->supplicant_ie)
 		c_iov = iov_ie_append(iov, n_iov, c_iov, hs->supplicant_ie,
 					IE_LEN(hs->supplicant_ie));
 
 	if (hs->supplicant_fte)
 		c_iov = iov_ie_append(iov, n_iov, c_iov, hs->supplicant_fte,
 					IE_LEN(hs->supplicant_fte));
 
 	if (hs->mde)
-- 
2.44.0


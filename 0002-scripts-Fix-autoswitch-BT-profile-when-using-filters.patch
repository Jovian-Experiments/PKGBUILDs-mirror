From ebea6c25d6a3c401ce558b838bd57473f31f35f6 Mon Sep 17 00:00:00 2001
From: Julian Bouzas <julian.bouzas@collabora.com>
Date: Thu, 6 Jun 2024 17:05:18 -0400
Subject: [PATCH 2/2] scripts: Fix autoswitch BT profile when using filters

If a source filter is used, the BT profile autoswitch does not work because
WirePlumber thinks there is always a client capturing audio from it. This patch
fixes the issue by recursively walking through the source filters that are
linked to the BT loopback source until a stream is found. If a stream is found
at the end of the chain, then it switches to HSP/HFP profile, if the stream is
not found, the profile stays to A2DP.
---
 .../device/autoswitch-bluetooth-profile.lua   | 36 ++++++++++++++++---
 1 file changed, 32 insertions(+), 4 deletions(-)

diff --git a/src/scripts/device/autoswitch-bluetooth-profile.lua b/src/scripts/device/autoswitch-bluetooth-profile.lua
index 7dd039f7..f1aba4e3 100644
--- a/src/scripts/device/autoswitch-bluetooth-profile.lua
+++ b/src/scripts/device/autoswitch-bluetooth-profile.lua
@@ -71,15 +71,27 @@ streams_om = ObjectManager {
   Interest {
     type = "node",
     Constraint { "media.class", "matches", "Stream/Input/Audio", type = "pw-global" },
+    Constraint { "node.link-group", "-", type = "pw" },
     Constraint { "stream.monitor", "!", "true", type = "pw" },
     Constraint { "bluez5.loopback", "!", "true", type = "pw" }
   }
 }
 
+filter_nodes_om = ObjectManager {
+  Interest {
+    type = "node",
+    Constraint { "node.link-group", "+", type = "pw" },
+    Constraint { "stream.monitor", "!", "true", type = "pw" },
+    Constraint { "bluez5.loopback", "!", "true", type = "pw" },
+  }
+}
+
 loopback_nodes_om = ObjectManager {
   Interest {
     type = "node",
     Constraint { "media.class", "matches", "Audio/Source", type = "pw-global" },
+    Constraint { "node.link-group", "+", type = "pw" },
+    Constraint { "stream.monitor", "!", "true", type = "pw" },
     Constraint { "bluez5.loopback", "=", "true", type = "pw" },
   }
 }
@@ -342,6 +354,24 @@ local function checkStreamStatus (stream)
 
         return dev_id
       end
+    else
+      -- Check if it is linked to a filter main node, and recursively advance if so
+      local filter_main_node = filter_nodes_om:lookup {
+        Constraint { "bound-id", "=", peer_id, type = "gobject" }
+      }
+      if filter_main_node ~= nil then
+        -- Now check the all stream nodes for this filter
+        local filter_link_group = filter_main_node.properties ["node.link-group"]
+        for filter_stream_node in filter_nodes_om:iterate {
+            Constraint { "media.class", "matches", "Stream/Input/Audio", type = "pw-global" },
+            Constraint { "node.link-group", "=", filter_link_group, type = "pw" }
+          } do
+          local dev_id = checkStreamStatus (filter_stream_node)
+          if dev_id ~= nil then
+            return dev_id
+          end
+        end
+      end
     end
   end
 
@@ -407,10 +437,7 @@ SimpleEventHook {
       local in_id = tonumber(p["link.input.node"])
       local out_id = tonumber(p["link.output.node"])
       local stream_id = tonumber(stream["bound-id"])
-      local bt_node = loopback_nodes_om:lookup {
-          Constraint { "bound-id", "=", out_id, type = "gobject" }
-      }
-      if in_id == stream_id and bt_node ~= nil then
+      if in_id == stream_id then
         handleStream (stream)
       end
     end
@@ -435,5 +462,6 @@ SimpleEventHook {
 
 devices_om:activate ()
 streams_om:activate ()
+filter_nodes_om:activate ()
 loopback_nodes_om:activate()
 
-- 
2.45.1

